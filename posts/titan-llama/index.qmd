---
title: "Titan-LLaMA: Cartridge-Style Neural Memory Adapters for LLMs"
author: 
  - "Sarah Pan"
  - "Sarah Dufays"
date: "2025-12-13"
# description: "Final Project for 6.7960, Massachusetts Institute of Technology"
image: "images/titans_overview.png"
bibliography: references.bib
draft: false
---

::: {.callout-warning}
This work was submitted as our final project for Deep Learning at MIT (6.7960). Much of the results are still preliminary and poorly ablated as work is ongoing.
:::

## Motivation

We read the Titans paper and really liked it, but we didn't want to train an end-to-end architecture from scratch. So instead, we came up with a new architecture that gives us the best of both worlds.

Off-the-shelf LLMs are extremely strong, but their expressivity is expensive as "memory" grows quadratically with sequence length. Among many others, Flash attention, sliding attention windows, linear attention, and KV-caching are techniques that provide speedups, but we were curious to know if we could **attach a learned state during post training for stateful, sub-quadratic memory**.

Titans is appealing in this regard because its memory is a deep architecture that accumulates information across full-attention segments. Rather than training a Titan model from scratch, we treat neural memory as a modular adapter that can be attached to a pretrained backbone whose long-range attention has been intentionally restricted.

Concretely, we freeze a pretrained LLaMA model, replace full attention with segmented attention, and attach a Titans-style Neural Memory Module (NMM) that serves as the sole mechanism for cross-segment information flow. The memory module functions as a drop-in "cartridge" that can be trained or swapped independently while the backbone remains fixed. To our knowledge, this is the first exploration of Titans-style neural memory used in this post-training, frozen-backbone regime.^[Maybe for good reason? The motivation is clear from a Titan-first perspective, perhaps less so from a Transformers-first one.] The result is an architecture that (i) generates tokens much faster as generation length grows and (ii) can be fine-tuned by swapping in task-specific memory adapters for downstream domains.

![Token throughput vs. generation length. Full-attention LLaMA slows down as sequences grow, while segmented attention keeps throughput roughly flat; we'll keep you posted if either of us learns enough CUDA to engineer kernels for this.](images/throughput_vs_generation.png)

::: {.callout-note}
Our prototype builds on an existing open-source Titans implementation that prioritizes correctness.^[Thanks to Phil Wang and other contributors for https://github.com/lucidrains/titans-pytorch !!] The neural memory kernels are probably under-optimized, introducing overhead that causes throughput to lag slightly behind full attention in practice. We consider this an engineering issue and expect substantial speedups from better implementation.
:::

## Background

Our inspiration for this work falls into two categories.

**Memory and state.** RNNs and LSTMs compress history into a fixed-size hidden vector but eventually forget distant information and cannot be parallelized. SSMs [@gu2022efficientlymodelinglongsequences] revisit this idea by improving stability and parallelizability. Transformers on the other hand store the entire sequence explicitly, relying on an attention "state" that grows quadratically with sequence length. For the record, we think it's totally understated how extremely parallelizable and expressive transformers are--but mitigating memory consumption is still a key concern.

**Parameter-efficient adapters.** Full fine-tuning is expensive and risks catastrophic forgetting. LoRA [@hu2021lora] instead adds trainable low-rank factors to frozen weight matrices, which reduces the trainable parameters by orders of magnitude while preserving expressivity. Prefix-tuning [@li2021prefixtuningoptimizingcontinuousprompts] prepends learned continuous prompts to the input sequence, allowing the model to behave as if conditioned on specific tasks or domains while keeping the backbone frozen.

### Titans: Deep Neural Memory as State

**Titans: deep neural memory as state.** Titans [@behrouz2024titanslearningmemorizetest] combines recurrent architectures as long-term memory with localized attention windows as short-term memory. These were the three things that we thought were the most important to understand from the paper. 

**1. Titans as a Mega-Abstraction of LSTMs.** Each cell state is a sub-sequence of tokens, but instead of forget gates and input gates, an MLP learns how to incorporate/get rid of information across a sequence. In other words, instead of carrying some $h_t$ forward, Titans carry a long-term memory module $M_t$ whose weights + fast gradient updates determine the state. 

![Reading from memory looks like "querying the state" via a forward pass, and updating the state looks like propgating a loss backward.](images/titans_overview.png)

**2. Fast and Slow Updates.** Long-term memory aims to memorize what happened at a previous attention window. Titans defines a "fast" memory loss $l(\mathcal{M}_{t -1}; x_t) = || q_t - k_t ||^2$ and updates its state over chunks in a sequence as such

$$
\mathcal{M}_t = (1 - \alpha_t) \mathcal{M}_{t - 1} + S_t \\ 
$$ {#eq-surprise-update}
$$
S_t = \eta_t S_{t - 1} - \theta_t \nabla l(\mathcal{M}_{t -1}; x_t).
$$

The surprise update rule is shown in @eq-surprise-update. Here, $\alpha_t$ serves as the gating mechanism, like that in RNNs. 

On the flip side, we still care about the language modeling objective and want to update the weights that parameterize $\mathcal{M}_t$ to optimize retrieval of the right information. These are the "slow updates" that operate on the timescale of our optimizer.

**3. This Can be Made Practical.** A naive implementation of these per-token weight updates is inherently sequential, but with a few tricks, you can actually vectorize much of the computation. If chunks within a sequence have length `b` and hidden size `d`, the rest of the computation is described as such:


```python
# X: [N, b, d]   (N chunks of b tokens)
u_prev = 0                      # last "update" state for this param (shape = param_shape)
m_prev[o] = 0 for o in 1..O     # last momentum states

for t in range(N):
    # 1) FAST write signal inside the chunk (parallel over b tokens)
    #    think: per-token grad of an associative loss wrt memory params
    s_tok = grad_mem_loss(M, X[t])            # shape: [b, param_shape]   (conceptually)

    # (optional) reduce tokens -> one chunk surprise (still parallel)
    s = sum_i theta[t,i] * s_tok[i]           # shape: [param_shape]

    # 2) SLOW accumulator across chunks (scan in t)
    for o in 1..O:
        m[o] = eta[o,t] * m_prev[o] + (s if o==1 else m[o-1])

    u = sum_o comb[o,t] * m[o]                # (this is the “einsum combine orders” idea)

    # 3) FORGET/DECAY across chunks (another scan)
    u = (1 - alpha[t]) * u_prev + u

    apply_update_to_memory(M, u)              # e.g., M <- M + u   (sign convention depends)
    u_prev, m_prev = u, m

```


## Methods

**Our perspective:** We combine these views by attaching Titan-style memory to a frozen LLaMA backbone and treating it as a cartridge-style adapter. The backbone stays fixed; only the Titan memory continues learning.

![The NMM (green) injects cross-segment attention entries, allowing information retrieval across segment boundaries without full-sequence attention.](images/nmm_bridge.png)

The next step of the process is to augment the localized attention calculation with "long-term memory" that is retrieved from the NMM. The NMM will try to recall what happened at the previous local attention window.

![As chunks c1–c5 progress, the NMM is queried then updated based on prediction error, making information persistent across the full sequence.](images/temporal_loop.png)

It might be helpful to "flip" the time axis when thinking about the fast update process. If we imagine each localized attention segment to be its own element in a sequence, this process closely resembles that of an LSTM or RNN. However, instead of learning weights that modulate previous hidden cell states, the hidden state itself is parameterized as a deep, learned architecture.

By storing the gradients for the surprisal-based loss, our neural memory module is essentially trained to remember all the prior attention outputs.

![Purple: frozen LLaMA. Green: trainable NMM + fast gradients. Only the memory "cartridge" adapts. The backbone is completely frozen: only ~2% of parameters are trainable.](images/full_architecture.png)

Finally, we propagate the language modeling loss over the weights of the NMMs and actually perform weight updates. It's important to note here that the rest of the weights in the pre-trained backbone are frozen and no updates are made to them. We can think of these "slow updates" as teaching the NMMs *how* to recall best.

### Attention Distillation Loss

In practice, we noticed that the pure language modeling objective was really easy for NMMs to master. And in fact, we do much better than our out-of-the-box LLM when evaluating next token prediction purely on a token accuracy / perplexity basis. However, when it came to the challenging language benchmarks that pre-trained LLMs excel at, solely using the language modeling loss was insufficient.

In our setting, we want the NMM to first recover baseline capabilities of the backbone LLM. We supervise the outputs of the Titan-agumented layers with that from our pre-trained backbone. In effect, we implicitly distill the expressivity from our pre-trained "teacher attention" into our adapter's recollection strategy only using a single additional forward pass at train-time.

::: {.callout-tip}
## Calculating Attention Distillation Loss

1. Compute normal forward pass
   a. Collect hidden states, these are "student" latents
2. Do a forward pass over the backbone, without segmented attn
   a. Collect hidden states, these are "teacher" latents
3. Compute MSE over these latents, scale, and add to LM loss
:::

## Experiments


**Hypothesis:** A Titans-style neural memory, used as an adapter on top of a frozen LLM backbone, can

**(1)** recover backbone LLM capabilities  
**(2)** and be fine-tuned to specialize in new domains.


**Experiment 1: Can Titan-LLaMA recover base LM abilities?**

We test whether the NMM can compensate for the information lost when replacing full attention with cheap segmented attention.

*1a. Language Modeling:* Train the Titan-LLaMA adapter on 1B tokens from SlimPajama-627B and FineWeb-EDU. Report validation perplexity and token accuracy.

*1b. NLP Benchmarks:* Evaluate on Winogrande [@sakaguchi2019winograndeadversarialwinogradschema], BoolQ [@clark2019boolqexploringsurprisingdifficulty], CommonsenseQA [@talmor2019commonsenseqaquestionansweringchallenge], DROP [@dua2019dropreadingcomprehensionbenchmark], and SQuAD v2 [@rajpurkar2018knowdontknowunanswerable]. Compare against frozen LLaMA (full attention) and segmented-only (ablation).

**Experiment 2: Domain Adaptation**

Can we train domain-specific NMMs that specialize to new areas?

- **Biomed:** PubMed corpus, PubMedQA [@jin2019pubmedqadatasetbiomedicalresearch]
- **Legal:** LexGLUE benchmark [@chalkidis2022lexgluebenchmarkdatasetlegal]
- **Math:** AQUA-RAT word problems [@ling2017programinductionrationalegeneration]

## Results

### Experimental Setup

We use [Llama-3.1-8b](https://huggingface.co/meta-llama/Llama-3.1-8B) as our pre-trained LLM backbone. For the NMMs, we attach 2-layer MLPs, with hidden dimension 2048 onto layers 4, 8, 12, 16, and 20. We use an attention segment length half the size of the data sequence length, a neural memory segment length of 64, and a neural memory batch size of 64.

For pre-training data, we use a 1b-token mixture of [Slim Pajama](https://huggingface.co/datasets/cerebras/SlimPajama-627B) and [FineWeb-EDU](https://huggingface.co/datasets/HuggingFaceFW/fineweb-edu). We fine-tune on the training sets of [PubMedQA](https://huggingface.co/datasets/qiaojin/PubMedQA), [CaseHOLD](https://huggingface.co/datasets/casehold/casehold), [AQUA-RAT](https://huggingface.co/datasets/deepmind/aqua_rat).

We find that higher neural learning rates (on the order of 1e-3) are helpful to performance. Gradient updates are performed with a learning rate of 3e-4 with a linear warmup and cosine annealing. Further, we weigh the distillation loss at 0.6 relative to language modeling loss. Due to the scope of the project, we were unable to thoroughly vet our hyperparameter setup--further work will explore annealing distillation loss weight and more tuning.

### Experiment 1 Results

We verified that imparing attention masks led to catastrophic results. Performance of Llama-Titan exceeded that of the frozen backbone on next-token prediction / language modeling.

| Model | Token Accuracy | Perplexity |
|-------|----------------|------------|
| Full-Attention LLaMA | 55.2% | 7.26 |
| Segmented-only (no NMM) | 0% | 1,516,042 |
| **Titan-LLaMA (Segmented + NMM)** | **100%** | **~1.0** |

The NMM not only recovers but actually exceeds baseline language modeling metrics—achieving 100% token accuracy vs. 55.2% for the original model. This suggests the NMM learns an effective compression of the training distribution.

This result validates the first part of our hypothesis—the NMM can recover capabilities lost to segmentation, at least for the language modeling objective. However, perfect scores (100% accuracy, ~1.0 perplexity) suggest possible overfitting to the training distribution rather than true generalization. This motivates our next experiment: do these gains transfer to downstream benchmarks?

Building on the language modeling success, we add attention distillation (described in Methods) to transfer rich representations to downstream tasks, and we achieve the following results:

| Benchmark | Full-Attn LLaMA | Segmented-only | Titan-LLaMA (LM loss) |
|-----------|-----------------|----------------|------------------------|
| Winogrande | 60.5% | 48.4% | 52.3% |
| BoolQ | 75.0% | 43% | 63% |
| CommonsenseQA | 75% | 13% | 20% |
| DROP | 59.5% | 0% | 27.3% |
| SquadV2 | 77% | 0% | 9% |

We therefore conclude that LM loss alone teaches the NMM to predict tokens, but not to build the rich intermediate representations that full attention provides. Attention distillation forces the NMM's hidden states to match the teacher model's representations, which is necessary for successful downstream task performance.

::: {.callout-note}
Random guessing for the above tasks are 50%, 50%, and 20% for Winogrande, BoolQ, and CommonsenseQA. 
DROP and SquadV2 are short open response.
:::

These results partially validate our hypothesis. The NMM does recover some benchmark performance (e.g., BoolQ improves by 20 percentage points over segmented-only), but does not fully match the frozen backbone. This gap could come from several factors... limited hyperparameter tuning, insufficient training compute, suboptimal NMM architecture choices (e.g., 2-layer MLPs may be too shallow), or potentially fundamental capacity limitations of the approach. Disentangling these factors would require more extensive ablations. The consistent improvement from distillation does confirm that representation quality, not just next-token prediction, is critical for downstream tasks.

### Experiment 2 Results

**Domain-specific fine-tuning.** We fine-tuned Titan-LLaMA on 3 domain-specific tasks:

| Benchmark | Full-Attn LLaMA | Segmented-only | Titan-LLaMA (fine-tuned) |
|-----------|-----------------|----------------|---------------------------|
| PubMedQA (Biomed) | **58%** | 46% | 55% |
| CaseHOLD (Legal) | **33%**| 19% | 24% |
| AQUA-RAT (Math) | **28%** | 22% | **28%** |

These results validate the second part of our hypothesis—the NMM can be fine-tuned to specialize in new domains. The varying recovery rates (75% for PubMedQA vs. 29% for CaseHOLD) suggest that some domains are easier to compress into learned memory than others.

PubMedQA shows the strongest recovery, closing 75% of the gap between segmented-only and full attention (from 46% to 55%, vs. 58% full attention). CaseHOLD and AQUA-RAT show more modest but still meaningful improvements.^[Again, these were super rushed experiments.]

## Limitations and Future Work

**1) Incomplete recovery.** Even with distillation, we don't fully recover full-attention performance on some of our benchmarks. The gap suggests that some information encoded in full attention is fundamentally difficult to compress into a learned memory module. Future work could explore larger NMM architectures or different distillation strategies.

**2) Throughput overhead.** Our current NMM implementation introduces computational overhead that negates the theoretical efficiency gains of segmented attention. As shown in Figure 1, the segmented+NMM model currently underperforms full attention in throughput. Optimized GPU and better memory management could address this.

**3) Limited hyperparameter tuning.** Due to compute and time constraints, only Winogrande and BoolQ were thoroughly tuned. Other benchmarks (CommonsenseQA, DROP, SQuAD) ran for ~30 training steps, so their scores are likely under-optimized. More extensive sweeps could improve results. We are particularly excited about distillation loss annealing.

**4) Scale.** All experiments use LLaMA-3.1-8B. We would like to test whether our findings generalize to larger models where the capacity gap between NMM and full attention may be more or less pronounced.

**5) Future directions.** Promising next steps include: (1) training NMMs from distillation alone without LM loss, (2) exploring different NMM architectures beyond 2-layer MLPs, (3) investigating whether NMMs can enable genuine continual learning without catastrophic forgetting, and (4) scaling to longer sequences where the efficiency benefits of segmentation become more pronounced.

## References

::: {#refs}
:::